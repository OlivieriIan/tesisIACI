\chapter{Diseño}
\thispagestyle{empty}

\section{Descripción del capítulo}
En este capítulo se desarrollarán y analizarán los requerimientos presentados en la sección \ref{sec:1.5} del capítulo 1 con el objetivo de determinar qué se planea hacer para cumplirlos.

\section{REQ-01} \label{sec:\thesection}
Para cumplir este requerimiento se debe contar con firmware que permita el manejo de: freno y leds indicadores (salidas digitales), fin de carrera (entrada digital), dipswitch (entrada analógica), encoders AB (interrupciones por cambio de estado de un pin), motor (generación de señal PWM) y DMX (comunicación serie). Además, como la placa de control no cuenta con un puerto de debug es necesario tener algún canal de comunicación alternativo, como un puerto serie por software. También será necesario temporizar ciertas partes del programa, por lo que se deberá poder manejar un timer.\\
El microcontrolador utilizado en la placa de control es el Atmega328p, que tiene capacidad de manejar todos los periféricos mencionados. El único inconveniente que presenta es que es un microcontrolador de 8 bits con relativamente baja memoria y sin optimizaciones para operaciones de punto flotante. 

Ahora, las opciones para manejar los periféricos del microcontrolador son: utilizar librerías ya hechas , siendo la de arduino la más recomendable, o generar unas propias. En la tabla \ref{table:2.1} se presenta una comparación entre ambas opciones.

\begin{table}[!ht]
	\begin{center}
		\begin{tabular}{|c|l|l|}
			\hline
			\textbf{} & \textbf{Arduino} & \textbf{Propia} \\
			\hline \hline
			Pros & - Listas para usar & - Bajo uso de recursos \\
			 & - Altamente testeadas  & - Confiabilidad \\
			 & - Mantenidas por una comunidad & - Predictibilidad \\
			 \hline
			Cons & - Genéricas (poco optimizadas) & - Tiempo de desarrollo alto por defecto \\
			& - Necesitan modificaciones para ser útiles & - Investigación y estudio \\
			& - Requieren análisis &   \\
			\hline
		\end{tabular}
	\end{center}
	\caption{Comparación entre el uso de librerías de Arduino vs el desarrollo de unas propias}
	\label{table:\thetable}
\end{table}

El mayor problema con las librerías de Arduino es que para que cuadren en proyectos grandes como estos requieren modificaciones, y cada módulo debe ser analizado para verificar que no se usen elementos como delays bloqueantes ni operaciones de punto flotante. \\
Como el objetivo es hacer que el sistema sea lo más confiable posible, y teniendo en cuenta que el tiempo de desarrollo no es un factor crítico, \textbf{se desarrollarán librerías propias para manejar los periféricos}.\\

\section{REQ-02} \label{sec:\thesection}
\subsection{Esquema de control}
Para cumplir con este requerimiento la carga se debe mover en respuesta a una referencia de posición y otra de velocidad indicadas por una consola DMX. Para esto se utilizará el esquema de control mostrado en la figura \ref{fig:2.1}, siendo: p la posición, v la velocidad,  Cp el controlador de posición, Cv el de velocidad, \(\varepsilon\)p y \(\varepsilon\)v los errores de posición y velocidad, u la acción de control, G la planta, y rp\_dmx y rv\_dmx las referencias de posición y velocidad dadas por la consola DMX.   \\

\begin{figure}[!ht]
	\centering
	\includegraphics[width=16cm,scale=1]{resources/2_1-diagramaControlador.png}
	\caption{Esquema de control a implementar}
	\label{fig:\thefigure}
\end{figure}

La elección de este esquema fue debido a su simpleza: un controlador de velocidad se encarga de mantener la velocidad igual a la referencia, mientras que uno de posición le indica al de velocidad que debe frenar cuando la posición objetivo está por ser alcanzada. Para evitar que el controlador de posición le indique al de velocidad una referencia mayor a la permitida, se utiliza un limitador en al referencia de velocidad. Similarmente, como la acción de control será el ciclo de trabajo del pwm que mueve al motor, se utiliza un segundo limitador para evitar que el ciclo de trabajo supere el 100 \%.

\subsection{Procedimiento para el diseño de control}
Primero se determinará el período de muestreo y actuación inyectándole un escalón unitario a planta.\\
Luego, se obtendrá el modelo de la planta mediante identificación paramétrica, haciendo uso de un método de estimación de tipo offline (no recursivo).\\
Luego se diseñarán los controladores de posición y velocidad en base al modelo de la planta obtenido\\
Finlamente se validarán los controladores hayados haciendo pruebas directamente sobre el updown.

\subsection{Relación entre cuentas de encoder y distancia}
A medida que el motor gira desenrrolla la polea para subir o bajar la carga. El problema es que dependiendo cuán enrrollada está la polea en el disco un mismo número de cuentas de encoder se puede traducir en distintas distancias recorridas por la carga. Por ejemplo, si la polea está completamente enrollada el radio es mayor, por lo que si giro 360 grados el carrete el largo desenrrollado será uno, mientras que si la polea se encuentra parcialmente desenrrollada el radio es menor, por lo que la distancia descendida en un giro de 360 grados del carrete será otra (menor que la anterior).\\

Para determinar esta relación se harán marcas cada un metro en la polea, tomando como 0 cuando esta está completamente enrrollada, y para cada una se anotará el valor del encoder del motor, que es el que más resolución tiene. Con estos datos se construirá una tabla, se encontrarán varios polinomios que fitteen los datos y se determinará cuál de ellos es el que se implementará en software.

\subsection{Velocidad máxima}
Una tarea a resolver es determinar cuál es la velocidad máxima posible para una carga determinada.\\

Para determinar este valor se medirá la velocidad para una carga de 3Kg en subida aplicando sobre el motor un pwm con ciclo de trabajo de 100\%.

La posición máxima posible queda dada por condiciones de diseño: 4 metros

\section{REQ-03} \label{sec:\thesection}
Los posibles errores detectables que se pueden tener en el equipo son:

\subsection{Corte de correa}
La transmisión de potencia entre el piñon en el eje del motor y la corona en el disco se hace a través de una correa. El problema es que durante las pruebas, la empresa observó que la correa podría cortarse. \\
La manera que tiene el equipo de detectar este error es mediante un segundo encoder AB que mide el giro del disco. Como la relación de vueltas entre el disco y el motor es proporcional, cualquier desviación grande de esta proporcionalidad indica que uno se está moviendo más rápidamente que el otro. Esto podría interpretarse como que la correa fue cortada o que alguno de los encoders dejó de funcionar, 2 errores válidos de hardware.

Para poder detectar estos errores lo primero que se hará es determinar la relación entre las cuentas del encoder del disco y las del motor. Luego verificará en el firmware que esta se cumpla en todo momento, bajo un cierto nivel de error aceptable. En caso de no cumplirse se accionará el freno, se detendrá el equipo completamente y se indicará sobre la existencia del error mediante el led de la placa de control (led interno).

\subsection{Fin de carrera}
La función principal del fin de carrera, un par de pulsadores en la base del equipo, es indicar cuándo la polea está completamente enrrollada para determinar la posición 0 o "home" del equipo, dado que este puede estar en cualquier posición al ser encendido.\\
La función secundaria del fin de carrera es detectar posibles eventos indeseados. Por ejemplo, en su punto más bajo la carga se encontrará a 4 metros por debajo del 0 del updown, por lo que podría comenzar a oscilar debido a fuertes vientos o personas que muevan la carga. Por cómo está construido el fin de carrera si la carga oscila más alla de un ángulo de aproximadamente 30 grados el fin de carrera se accionará dando aviso de esto.

Para poder detectar estos errores se verificará que el fin de carrea no sea presionado fuera de la rutina de calibración de (homing). En caso de que sea presionado en estas condiciones se detendrá el equipo, se esperará un tiempo a que la oscilación baje, y intentarán reanudar las operaciones normales. En caso de que el fin de carrera siga presionado se accionará el freno, se detendrá el equipo completamente y se indicará sobre la existencia del error mediante el led de la placa de control (led interno).


\subsection{Pérdida de DMX}
El estándar DMX establece que el tiempo máximo entre un paquete de datos y otro, tiempo de IDLE o MTBP (ver tabla \ref{table:1.1}), es de 1 segundo. Esto quiere decir que si por 1 segundo no me llegaron nuevos datos se considera que se perdió la comunicación con el dispositivo DMX.

Para detectar la pérdida de señal de DMX se verificará constantemente que el último paquete haya llegado hace menos de 1 segundo. En caso de no cumplirse se asumirá que las referencias de posición y velocidad son 0 (equipo parado). Además, por una convención en equipos DMX, se indicará mediante el led en el dipswitch (led externo) cuándo el equipo recibe correctamente la señal de DMX y cuándo no, encendiendolo y apagándolo rápidamente en el primer caso y lentamente en el segundo.


\section{REQ-04} \label{sec:\thesection}
El propósito del dipswitch en el equipo es poder seleccionar el canal principal de DMX a partir del cual leer las referencias de posición y velocidad, dentro de los 512 canales que tiene un universo DMX. Para lograr esto cuenta con 10 switchs, 9 que determinan el canal de DMX (\( 2^9 = 512 \)) y uno extra para ampliaciones futuras. Estos conmutadores conectan o desconectan resistencias de unos divisores de tensión resistivos, variando el valor entregado por cada uno de ellos. Como el dipswitch cuenta con 3 divisores se tienen 3 salidas analógicas, que dan información de qué switchs están activados y cuales no. \\
El esquéma de uno de los divisores se puede ver en la figura \ref{fig:2.2}. Para completar con el desarrollo del dipswitch se deben encontrar 5 valores de resistencias (R1,R2,R3,R4 y R).

Para hayar estos 5 valores se simulará el divisor de tensión en Matlab, probando con distintas combinaciones de resistencias hasta que los valores analógicos de la salida para cada combinación de resistencia estén lo suficientemente separados.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=8cm,scale=1]{resources/2_2-dipswitch.png}
	\caption{Diagrama de uno de los 3 divisores del dipswitch}
	\label{fig:\thefigure}
\end{figure}


\section{Diagrama de módulos del firmware}
Para que el firmware del sistema sea escalable y mantenible se separarán los distintos programas del proyecto en módulos. El diagrama de módulos a implementar se muestra en la figura \ref{fig:2.3}\\

\begin{figure}[!ht]
	\centering
	\includegraphics[width=14cm,scale=1]{resources/2_3-diagramaDeModulos.png}
	\caption{Diagrama de módulos del firmware}
	\label{fig:\thefigure}
\end{figure}
